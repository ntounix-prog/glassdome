"""
Reaper Exploit Library

Database models and management for the vulnerability/exploit library.
This is the source of truth for all exploits that can be injected.
"""

from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, JSON, Enum as SQLEnum, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from typing import Dict, Any, List, Optional
from datetime import datetime
from enum import Enum
import logging

from glassdome.core.database import Base

logger = logging.getLogger(__name__)


class ExploitType(str, Enum):
    """Categories of exploits"""
    WEB = "web"                    # SQL injection, XSS, CSRF, etc.
    NETWORK = "network"            # SMB, RDP, SSH exploits
    PRIVILEGE_ESCALATION = "privesc"  # sudo, SUID, kernel exploits
    CREDENTIAL = "credential"      # Weak passwords, kerberoasting
    MISCONFIGURATION = "misconfig" # Insecure services, open shares
    MALWARE = "malware"           # Backdoors, RATs (for training)
    ACTIVE_DIRECTORY = "ad"       # AD-specific attacks
    CUSTOM = "custom"             # User-defined


class ExploitSeverity(str, Enum):
    """CVSS-style severity ratings"""
    CRITICAL = "critical"  # 9.0-10.0
    HIGH = "high"          # 7.0-8.9
    MEDIUM = "medium"      # 4.0-6.9
    LOW = "low"            # 0.1-3.9
    INFO = "info"          # Informational


class ExploitOS(str, Enum):
    """Target operating systems"""
    LINUX = "linux"
    WINDOWS = "windows"
    MACOS = "macos"
    ANY = "any"


class Exploit(Base):
    """
    Definition of a single exploit/vulnerability
    
    This is the library of "what can be injected"
    """
    __tablename__ = "exploits"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # Identity
    name = Column(String(255), nullable=False, unique=True)
    display_name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    
    # Classification
    cve_id = Column(String(50), nullable=True, index=True)  # e.g., CVE-2021-44228
    exploit_type = Column(String(50), nullable=False, default=ExploitType.CUSTOM.value)
    severity = Column(String(20), nullable=False, default=ExploitSeverity.MEDIUM.value)
    cvss_score = Column(String(10), nullable=True)  # e.g., "9.8"
    
    # Targeting
    target_os = Column(String(20), nullable=False, default=ExploitOS.LINUX.value)
    target_services = Column(JSON, nullable=True)  # ["apache", "mysql"]
    prerequisites = Column(JSON, nullable=True)    # ["ssh_access", "web_server"]
    
    # Implementation
    package_name = Column(String(255), nullable=True)  # APT/chocolatey package
    install_script = Column(Text, nullable=True)       # Custom install script
    verify_script = Column(Text, nullable=True)        # Script to verify exploit works
    cleanup_script = Column(Text, nullable=True)       # Remediation/cleanup script
    
    # Ansible Integration - for engineers/architects building playbooks
    ansible_playbook = Column(String(255), nullable=True)  # Path to playbook (e.g., "web/inject_sqli.yml")
    ansible_role = Column(String(255), nullable=True)      # Ansible role name if using roles
    ansible_vars = Column(JSON, nullable=True)             # Default variables for playbook
    
    # Documentation
    exploitation_steps = Column(Text, nullable=True)   # How to exploit (for training)
    remediation_steps = Column(Text, nullable=True)    # How to fix
    references = Column(JSON, nullable=True)           # URLs, papers, etc.
    tags = Column(JSON, nullable=True)                 # ["owasp-top-10", "web"]
    
    # Status
    verified = Column(Boolean, default=False)          # Has been tested
    enabled = Column(Boolean, default=True)            # Available for missions
    
    # Metadata
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    created_by = Column(String(100), nullable=True)
    
    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "display_name": self.display_name,
            "description": self.description,
            "cve_id": self.cve_id,
            "exploit_type": self.exploit_type,
            "severity": self.severity,
            "cvss_score": self.cvss_score,
            "target_os": self.target_os,
            "target_services": self.target_services,
            "prerequisites": self.prerequisites,
            "package_name": self.package_name,
            "has_install_script": bool(self.install_script),
            "has_verify_script": bool(self.verify_script),
            "install_script": self.install_script,
            "verify_script": self.verify_script,
            "cleanup_script": self.cleanup_script,
            "ansible_playbook": self.ansible_playbook,
            "ansible_role": self.ansible_role,
            "ansible_vars": self.ansible_vars,
            "exploitation_steps": self.exploitation_steps,
            "remediation_steps": self.remediation_steps,
            "references": self.references,
            "tags": self.tags,
            "verified": self.verified,
            "enabled": self.enabled,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }


class ExploitMission(Base):
    """
    A mission to inject exploits into target VMs
    
    Links exploits to VMs and tracks execution status
    """
    __tablename__ = "exploit_missions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # Identity
    mission_id = Column(String(100), nullable=False, unique=True, index=True)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    
    # Target
    platform = Column(String(50), nullable=False)  # proxmox, aws, esxi, azure
    target_vm_id = Column(String(255), nullable=True)  # Existing VM
    target_vm_config = Column(JSON, nullable=True)     # Config to create new VM
    
    # Exploits to inject
    exploit_ids = Column(JSON, nullable=False)  # [1, 2, 3]
    
    # Execution
    status = Column(String(50), default="pending")  # pending, deploying_vm, injecting, verifying, completed, failed
    progress = Column(Integer, default=0)  # 0-100
    current_step = Column(String(255), nullable=True)
    
    # Results
    vm_created_id = Column(String(255), nullable=True)  # VM ID if we created it
    vm_ip_address = Column(String(50), nullable=True)
    results = Column(JSON, nullable=True)  # {exploit_id: {status, output, verified}}
    error_message = Column(Text, nullable=True)
    
    # Timing
    created_at = Column(DateTime, default=func.now())
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    
    # Relationships
    logs = relationship("MissionLog", back_populates="mission", cascade="all, delete-orphan")
    validations = relationship("ValidationResult", back_populates="mission", cascade="all, delete-orphan")
    
    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary"""
        return {
            "id": self.id,
            "mission_id": self.mission_id,
            "name": self.name,
            "description": self.description,
            "platform": self.platform,
            "target_vm_id": self.target_vm_id,
            "target_vm_config": self.target_vm_config,
            "exploit_ids": self.exploit_ids,
            "status": self.status,
            "progress": self.progress,
            "current_step": self.current_step,
            "vm_created_id": self.vm_created_id,
            "vm_ip_address": self.vm_ip_address,
            "results": self.results,
            "error_message": self.error_message,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
        }


class MissionLog(Base):
    """
    Log entries for a mission - stored in SQL for portability
    Retained for 2 weeks, then auto-purged
    """
    __tablename__ = "mission_logs"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    mission_id = Column(String(100), ForeignKey("exploit_missions.mission_id"), nullable=False, index=True)
    
    # Log entry
    level = Column(String(20), nullable=False, default="INFO")  # DEBUG, INFO, WARNING, ERROR
    message = Column(Text, nullable=False)
    details = Column(JSON, nullable=True)  # Additional structured data
    
    # Context
    step = Column(String(100), nullable=True)  # e.g., "deploying_vm", "injecting_exploit"
    exploit_id = Column(Integer, nullable=True)  # If related to specific exploit
    
    # Timing
    timestamp = Column(DateTime, default=func.now(), index=True)
    
    # Relationship
    mission = relationship("ExploitMission", back_populates="logs")
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "mission_id": self.mission_id,
            "level": self.level,
            "message": self.message,
            "details": self.details,
            "step": self.step,
            "exploit_id": self.exploit_id,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
        }


class ValidationResult(Base):
    """
    WhiteKnight validation results - linked to missions
    Retained for 2 weeks with the mission
    """
    __tablename__ = "validation_results"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    mission_id = Column(String(100), ForeignKey("exploit_missions.mission_id"), nullable=False, index=True)
    
    # Validation info
    test_name = Column(String(100), nullable=False)
    test_type = Column(String(50), nullable=False)  # connectivity, credential, network, web, privesc
    
    # Results
    status = Column(String(20), nullable=False)  # success, failed, error
    message = Column(Text, nullable=True)
    evidence = Column(Text, nullable=True)
    
    # Context
    target_ip = Column(String(50), nullable=True)
    credentials_tested = Column(JSON, nullable=True)  # ["ubuntu:ubuntu", "vulnuser:password123"]
    
    # Timing
    validated_at = Column(DateTime, default=func.now(), index=True)
    duration_ms = Column(Integer, nullable=True)  # How long the test took
    
    # Relationship
    mission = relationship("ExploitMission", back_populates="validations")
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "mission_id": self.mission_id,
            "test_name": self.test_name,
            "test_type": self.test_type,
            "status": self.status,
            "message": self.message,
            "evidence": self.evidence,
            "target_ip": self.target_ip,
            "credentials_tested": self.credentials_tested,
            "validated_at": self.validated_at.isoformat() if self.validated_at else None,
            "duration_ms": self.duration_ms,
        }


# ============================================================================
# Default Exploits Library
# ============================================================================

DEFAULT_EXPLOITS = [
    {
        "name": "sql-injection-basic",
        "display_name": "SQL Injection (Basic)",
        "description": "Classic SQL injection vulnerability in web application login form",
        "cve_id": None,
        "exploit_type": ExploitType.WEB.value,
        "severity": ExploitSeverity.HIGH.value,
        "cvss_score": "7.5",
        "target_os": ExploitOS.LINUX.value,
        "target_services": ["apache2", "mysql"],
        "prerequisites": ["web_server"],
        "package_name": "glassdome-vuln-sqli",
        "exploitation_steps": """1. Navigate to login page
2. Enter username: ' OR '1'='1' --
3. Enter any password
4. Observe successful bypass""",
        "remediation_steps": """1. Use parameterized queries
2. Implement input validation
3. Use prepared statements""",
        "tags": ["owasp-top-10", "injection", "web"],
        "verified": True,
        "enabled": True,
    },
    {
        "name": "xss-stored",
        "display_name": "Cross-Site Scripting (Stored XSS)",
        "description": "Stored XSS vulnerability in comment/feedback form",
        "cve_id": None,
        "exploit_type": ExploitType.WEB.value,
        "severity": ExploitSeverity.MEDIUM.value,
        "cvss_score": "6.1",
        "target_os": ExploitOS.LINUX.value,
        "target_services": ["apache2", "php"],
        "prerequisites": ["web_server"],
        "package_name": "glassdome-vuln-xss",
        "exploitation_steps": """1. Navigate to comment form
2. Enter: <script>alert('XSS')</script>
3. Submit comment
4. Reload page - observe alert""",
        "remediation_steps": """1. Sanitize all user input
2. Use output encoding
3. Implement Content Security Policy""",
        "tags": ["owasp-top-10", "xss", "web"],
        "verified": True,
        "enabled": True,
    },
    {
        "name": "weak-ssh-password",
        "display_name": "Weak SSH Credentials",
        "description": "SSH server with weak/default credentials (user:password123)",
        "cve_id": None,
        "exploit_type": ExploitType.CREDENTIAL.value,
        "severity": ExploitSeverity.HIGH.value,
        "cvss_score": "7.5",
        "target_os": ExploitOS.LINUX.value,
        "target_services": ["ssh"],
        "prerequisites": ["ssh_server"],
        "package_name": None,
        "install_script": """#!/bin/bash
# Create vulnerable user
useradd -m -s /bin/bash vulnuser
echo 'vulnuser:password123' | chpasswd
# Enable password auth
sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config
systemctl restart ssh
""",
        "verify_script": """#!/bin/bash
sshpass -p 'password123' ssh -o StrictHostKeyChecking=no vulnuser@localhost echo 'SUCCESS'
""",
        "exploitation_steps": """1. Use hydra or medusa for brute force
2. Or try common credentials: vulnuser:password123
3. ssh vulnuser@target_ip""",
        "remediation_steps": """1. Use strong passwords
2. Disable password authentication
3. Use SSH keys only
4. Implement fail2ban""",
        "tags": ["credential", "ssh", "brute-force"],
        "verified": True,
        "enabled": True,
    },
    {
        "name": "sudo-nopasswd",
        "display_name": "Sudo NOPASSWD Misconfiguration",
        "description": "User can run commands as root without password via misconfigured sudoers",
        "cve_id": None,
        "exploit_type": ExploitType.PRIVILEGE_ESCALATION.value,
        "severity": ExploitSeverity.HIGH.value,
        "cvss_score": "7.8",
        "target_os": ExploitOS.LINUX.value,
        "target_services": [],
        "prerequisites": ["local_access"],
        "package_name": None,
        "install_script": """#!/bin/bash
# Create user with sudo NOPASSWD
useradd -m -s /bin/bash privuser
echo 'privuser:privuser123' | chpasswd
echo 'privuser ALL=(ALL) NOPASSWD: /usr/bin/vim' >> /etc/sudoers
""",
        "verify_script": """#!/bin/bash
echo 'privuser123' | su - privuser -c 'sudo vim -c ":!whoami" -c ":q!"' 2>&1 | grep -q root && echo 'SUCCESS'
""",
        "exploitation_steps": """1. Login as privuser
2. Run: sudo vim
3. In vim, type :!bash
4. You now have root shell""",
        "remediation_steps": """1. Review sudoers file
2. Remove NOPASSWD entries
3. Limit sudo to specific commands
4. Use sudo with password requirement""",
        "tags": ["privesc", "sudo", "misconfiguration"],
        "verified": True,
        "enabled": True,
    },
    {
        "name": "smb-anonymous",
        "display_name": "SMB Anonymous Access",
        "description": "SMB share with anonymous/guest access enabled",
        "cve_id": None,
        "exploit_type": ExploitType.NETWORK.value,
        "severity": ExploitSeverity.MEDIUM.value,
        "cvss_score": "5.3",
        "target_os": ExploitOS.LINUX.value,
        "target_services": ["smb", "samba"],
        "prerequisites": ["network_access"],
        "package_name": "samba",
        "install_script": """#!/bin/bash
apt-get install -y samba
mkdir -p /srv/share
chmod 777 /srv/share
echo 'Sensitive data here!' > /srv/share/secrets.txt

cat >> /etc/samba/smb.conf << 'EOF'
[public]
   path = /srv/share
   guest ok = yes
   browseable = yes
   read only = no
   create mask = 0777
EOF

systemctl restart smbd
""",
        "verify_script": """#!/bin/bash
smbclient -N -L localhost 2>&1 | grep -q public && echo 'SUCCESS'
""",
        "exploitation_steps": """1. Scan for SMB: nmap -p445 target
2. List shares: smbclient -N -L //target
3. Connect: smbclient -N //target/public
4. Download files: get secrets.txt""",
        "remediation_steps": """1. Disable guest access
2. Require authentication
3. Set proper permissions
4. Use firewall rules""",
        "tags": ["network", "smb", "anonymous"],
        "verified": True,
        "enabled": True,
    },
    {
        "name": "dvwa-full",
        "display_name": "DVWA (Damn Vulnerable Web App)",
        "description": "Full DVWA installation with multiple vulnerabilities",
        "cve_id": None,
        "exploit_type": ExploitType.WEB.value,
        "severity": ExploitSeverity.HIGH.value,
        "cvss_score": "8.0",
        "target_os": ExploitOS.LINUX.value,
        "target_services": ["apache2", "mysql", "php"],
        "prerequisites": ["web_server", "database"],
        "package_name": "glassdome-dvwa",
        "install_script": """#!/bin/bash
apt-get update
apt-get install -y apache2 mysql-server php php-mysql php-gd libapache2-mod-php git

# Clone DVWA
git clone https://github.com/digininja/DVWA.git /var/www/html/dvwa

# Configure
cp /var/www/html/dvwa/config/config.inc.php.dist /var/www/html/dvwa/config/config.inc.php
chown -R www-data:www-data /var/www/html/dvwa

# Setup database
mysql -e "CREATE DATABASE dvwa;"
mysql -e "CREATE USER 'dvwa'@'localhost' IDENTIFIED BY 'p@ssw0rd';"
mysql -e "GRANT ALL PRIVILEGES ON dvwa.* TO 'dvwa'@'localhost';"

systemctl restart apache2
""",
        "exploitation_steps": """1. Navigate to http://target/dvwa
2. Login: admin / password
3. Setup database via setup.php
4. Explore: SQL Injection, XSS, File Upload, Command Injection, CSRF, etc.""",
        "remediation_steps": """This is a training application - not meant for production.
To secure: Remove DVWA from production systems.""",
        "tags": ["owasp-top-10", "training", "web", "comprehensive"],
        "verified": True,
        "enabled": True,
    },
]


async def seed_default_exploits(session):
    """
    Seed the database with default exploits
    
    Args:
        session: SQLAlchemy async session
    """
    from sqlalchemy import select
    
    for exploit_data in DEFAULT_EXPLOITS:
        # Check if already exists
        result = await session.execute(
            select(Exploit).where(Exploit.name == exploit_data["name"])
        )
        existing = result.scalar_one_or_none()
        
        if not existing:
            exploit = Exploit(**exploit_data)
            session.add(exploit)
            logger.info(f"Seeded exploit: {exploit_data['name']}")
    
    await session.commit()
    logger.info("Default exploits seeded successfully")

